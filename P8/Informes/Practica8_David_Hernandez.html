<!DOCTYPE html><html><head>
      <title>Practica8_David_Hernandez</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:////Users/davidhm/.vscode/extensions/shd101wyy.markdown-preview-enhanced-0.8.18/crossnote/dependencies/katex/katex.min.css">
      
      
      
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<h1 id="practica-8---buses-de-comunicación-iv-uart">PRACTICA 8 :  Buses de comunicación IV (uart) </h1>
<h2 id="material">MATERIAL </h2>
<p>Para esta practica necesitaremos el microcontrolador ESP32, Tarjeta microSD y módulo lector, altavoz, cables y una protoboard.</p>
  <div style="display: flex; justify-content: center; gap: 10px;">
      <img src="https://ae04.alicdn.com/kf/S8dee2f4cafc344e1b57ebc21ad5c11a4P.jpg" alt="ESP32" width="150">
      <img src="https://www.luisllamas.es/wp-content/uploads/2016/09/arduino-gps-neo-6-componente.png" alt="ESP32" width="180">
      <img src="https://images-na.ssl-images-amazon.com/images/I/51UYHk3iK4L._AC_.jpg" alt="ESP32" width="150">
      <img src="https://cdn.bodanius.com/media/1/0d8100207_breadboard-wit-400-punten_x.png" alt="Protoaboard" width="150">
      <img src="https://http2.mlstatic.com/D_NQ_NP_878530-MLA75569986696_042024-O.webp" alt="Cables" width="150">
  </div>
<h3 id="objetivo-y-funcionalidad-de-la-practica">OBJETIVO Y FUNCIONALIDAD DE LA PRACTICA </h3>
<p>El objetivo de la practica es comprender el funcionamiento de la comunicacion serie asincrona usart. Esta comunicacion  es muy utilizada de hecho en todas las practicas las estamos usando cuando nos referimos a la impresora serie  Serial.println("").</p>
<p>Este tipo de protocolo dispone de muchos perifericos  y por tanto la comprension de su funcionamiento es basica para cualquier  ingeniero electronico.</p>
<p>En la practica de hoy  veremos dos ejemplos de uso . La conexion a un modulo GPS  de donde visualizaremos  la posicion , velocidad y hora actual  y una conexion a internet mediante un modem GSM/ GPRS</p>
<h3 id="software-de-arduino">Software de arduino </h3>
<p>El control de los perifericos viene soportado en arduino por una API (objeto) Serial, derivada de la clase stream con la que se puede controlar con facilidad  cualquier protocolo de comunicación .</p>
<p><a href="https://www.arduino.cc/reference/en/language/functions/communication/serial/">https://www.arduino.cc/reference/en/language/functions/communication/serial/</a></p>
<p>Las funciones principales són:</p>
<ul>
<li>if(Serial): Verifica si el puerto serial está listo<pre data-role="codeBlock" data-info="" class="language-text"><code>void setup() {
  Serial.begin(9600);
  while (!Serial); // Espera a que el puerto esté listo
  Serial.println("Serial listo");
}
</code></pre></li>
<li>available(): Devuelve el número de bytes disponibles para leer.<pre data-role="codeBlock" data-info="" class="language-text"><code>void loop() {
  if (Serial.available() &gt; 0) {
    char c = Serial.read();
    Serial.print("Recibido: ");
    Serial.println(c);
  }
}
</code></pre></li>
<li>availableForWrite(): Devuelve cuántos bytes se pueden escribir sin bloquear.<pre data-role="codeBlock" data-info="" class="language-text"><code>void loop() {
  int espacio = Serial.availableForWrite();
  Serial.println(espacio);
  delay(1000);
}
</code></pre></li>
<li>begin(): Inicia la comunicación serial.<pre data-role="codeBlock" data-info="" class="language-text"><code>void setup() {
  Serial.begin(9600);
}
</code></pre></li>
<li>end(): Detiene la comunicación serial.<pre data-role="codeBlock" data-info="" class="language-text"><code>void loop() {
  Serial.end();
  delay(1000);
}
</code></pre></li>
<li>find(): Busca una secuencia específica de caracteres.<pre data-role="codeBlock" data-info="" class="language-text"><code>void loop() {
  if (Serial.find("OK")) {
    Serial.println("Comando OK recibido");
  }
}
</code></pre></li>
<li>findUntil(): Busca hasta encontrar un texto o hasta que otro lo cancele.<pre data-role="codeBlock" data-info="" class="language-text"><code>void loop() {
  if (Serial.findUntil("OK", "CANCEL")) {
    Serial.println("Encontrado OK (no cancelado)");
  }
}
</code></pre></li>
<li>flush(): limpia el buffer de salida<pre data-role="codeBlock" data-info="" class="language-text"><code>void loop() {
  Serial.print("Enviando datos...");
  Serial.flush(); // Espera a que termine de enviarse todo
}
</code></pre></li>
<li>parseFloat(): Lee el siguiente número en punto flotante del buffer.<pre data-role="codeBlock" data-info="" class="language-text"><code>void loop() {
  if (Serial.available()) {
    float valor = Serial.parseFloat();
    Serial.println(valor);
  }
}
</code></pre></li>
<li>parseInt(): Lee el siguiente número entero del buffer.<pre data-role="codeBlock" data-info="" class="language-text"><code>void loop() {
  if (Serial.available()) {
    int num = Serial.parseInt();
    Serial.println(num);
  }
}
</code></pre></li>
<li>peek(): Mira el siguiente byte sin eliminarlo del buffer.<pre data-role="codeBlock" data-info="" class="language-text"><code>void loop() {
  if (Serial.available()) {
    char c = Serial.peek();
    Serial.print("Próximo carácter: ");
    Serial.println(c);
  }
}
</code></pre></li>
<li>print(): Envía datos al puerto serial (sin salto de línea).<pre data-role="codeBlock" data-info="" class="language-text"><code>void loop() {
  Serial.print("Hola ");
  Serial.print("Mundo");
}
</code></pre></li>
<li>println(): Envía datos al puerto serial (con salto de línea).<pre data-role="codeBlock" data-info="" class="language-text"><code>void loop() {
  Serial.println("Hola con salto de línea");
}
</code></pre></li>
<li>read(): Lee 1 byte del buffer de entrada.<pre data-role="codeBlock" data-info="" class="language-text"><code>void loop() {
  if (Serial.available()) {
    char c = Serial.read();
    Serial.print("Leído: ");
    Serial.println(c);
  }
}
</code></pre></li>
<li>readBytes(): Lee varios bytes en un buffer.<pre data-role="codeBlock" data-info="" class="language-text"><code>char datos[10];

void loop() {
  if (Serial.available() &gt;= 10) {
    Serial.readBytes(datos, 10);
    Serial.println("Leídos 10 bytes");
  }
}
</code></pre></li>
<li>readBytesUntil(): Lee bytes hasta cierto carácter o máximo longitud.<pre data-role="codeBlock" data-info="" class="language-text"><code>char datos[20];

void loop() {
  if (Serial.available()) {
    Serial.readBytesUntil('\n', datos, 20);
    Serial.println(datos);
  }
}
</code></pre></li>
<li>readString(): Lee todo lo disponible como cadena.<pre data-role="codeBlock" data-info="" class="language-text"><code>void loop() {
  if (Serial.available()) {
    String texto = Serial.readString();
    Serial.println("Texto recibido:");
    Serial.println(texto);
  }
}
</code></pre></li>
<li>readStringUntil(): Lee hasta encontrar el delimitador.<pre data-role="codeBlock" data-info="" class="language-text"><code>void loop() {
  if (Serial.available()) {
    String dato = Serial.readStringUntil(',');
    Serial.println("Parte recibida:");
    Serial.println(dato);
  }
}
</code></pre></li>
<li>setTimeout(): Define cuánto tiempo espera parseInt, readBytes, etc.<pre data-role="codeBlock" data-info="" class="language-text"><code>void setup() {
  Serial.begin(9600);
  Serial.setTimeout(5000); // Espera hasta 5 segundos
}
</code></pre></li>
<li>write(): Envía datos como bytes.<pre data-role="codeBlock" data-info="" class="language-text"><code>void loop() {
  Serial.write('A'); // Envía byte ASCII de 'A'
  delay(1000);
}
</code></pre></li>
<li>serialEvent(): Función especial que se ejecuta cuando hay datos disponibles (solo si usas SerialEvent() y no bloqueas loop()).<pre data-role="codeBlock" data-info="" class="language-text"><code>void serialEvent() {
  while (Serial.available()) {
    char c = Serial.read();
    Serial.print("Evento: ");
    Serial.println(c);
  }
}
</code></pre></li>
</ul>
<h2 id="ejercicio-practico-1--bucle-de-comunicacion-uart2">Ejercicio practico 1:  Bucle de comunicacion uart2 </h2>
<p>Enunciado :  Realizar  un bucle de comunicacion de forma que los datos que se manden  por el terminal   rxd0  se redirijan a la uart 2  txd2 ( que debe estar conectado a rxd2 ) y la recepcion de los datos de la uart2  se reenvien de nuevo a la salida txd0  para que aparezcan en la pantalla del terminal</p>
<h4 id="código-comentado">Código comentado </h4>
<pre data-role="codeBlock" data-info="" class="language-text"><code>// Se incluye la librería principal de Arduino para poder usar sus funciones
#include &lt;Arduino.h&gt;  

// Se define el pin 16 como RX (recepción) de la UART1
#define RXD1 16  

// Se define el pin 17 como TX (transmisión) de la UART1
#define TXD1 17  

void setup() {
  // Se inicia la comunicación serie USB a 115200 baudios
  Serial.begin(115200);  

  // Espera a que el puerto serie esté listo (útil en placas que lo requieren)
  while (!Serial);       

  // Se inicia UART1 con 9600 baudios, 8 bits de datos, sin paridad, 1 bit de parada usando los pines RXD1 y TXD1
  Serial1.begin(9600, SERIAL_8N1, RXD1, TXD1);  

  // Mensaje inicial de arranque que se muestra por el monitor serie
  Serial.println("Bucle UART con ESP32-S3 iniciado");  
}

void loop() {
  // Variable para almacenar el texto ingresado por el usuario desde el monitor serie
  static String inputString = "";  

  // Si hay datos disponibles en el monitor serie (USB), se leen
  if (Serial.available()) {

    // Se lee un carácter
    char incomingByte = Serial.read();  

    // Si se detecta el fin de línea (enter), se considera que la cadena está completa
    if (incomingByte == '\n' || incomingByte == '\r') {
      if (inputString.length() &gt; 0) {

        // Se envía la cadena completa por UART1
        Serial1.write(inputString.c_str());  

        // Se muestra en el monitor serie lo que se envió
        Serial.println("Enviado a UART1: " + inputString);  

        // Se limpia la cadena para recibir una nueva
        inputString = "";  
      }
    } else {
      // Si no es salto de línea, se agrega el carácter a la cadena
      inputString += incomingByte;  
    }
  }

  // Si hay datos recibidos por UART1, se leen y se muestran en el monitor serie
  if (Serial1.available()) {
    // Se lee un carácter recibido por UART1
    char receivedByte = Serial1.read();  

    // Se envía directamente al monitor serie (USB)
    Serial.write(receivedByte);  
}
</code></pre><h4 id="funcionamiento">Funcionamiento </h4>
<ol>
<li>Lee lo que escribes en el monitor serie del ordenador.</li>
<li>Cuando presionas ENTER, envía ese texto por los pines UART1 (TX: 17, RX: 16).</li>
<li>Si el dispositivo conectado a esos pines responde, muestra esa respuesta en el monitor serie del ordenador.</li>
</ol>
<p>En resumen:<br>
•	USB ↔ ESP32 ↔ UART1 (otro dispositivo)<br>
•	Sirve como puente de comunicación o consola de prueba entre el PC y un módulo externo (como un GPS, módulo Bluetooth, otro micro, etc.).</p>
<p>Para que poder visualizar el mensaje que escribes por pantalla es necesario ejecutar este codigo en la terminal:</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>pio device monitor --echo --baud 115200
</code></pre><p>También puedes ejecutar el código como lo hacemos normalmente, pero no verás tu mensaje hasta que cliques el enter.</p>
<h4 id="salida-monitor-serial">Salida Monitor Serial </h4>
<p>Este mensaje aparece al encender el ESP32, indicando que el programa ha comenzado y está listo.</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>Bucle UART con ESP32-S3 iniciado
</code></pre><p>Cuando escribes un texto en el monitor serial y pulsas Enter:<br>
•	El ESP32 lo captura y lo envía por UART1 al dispositivo conectado.<br>
•	Además, te muestra esto:</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>Enviado a UART1: tu_mensaje
</code></pre><p>Si el dispositivo conectado por UART1 (TXD1 y RXD1) responde, cada carácter recibido aparecerá tal cual en el monitor serial, sin prefijo.</p>
<h4 id="video-y-foto-demostración">Video y foto demostración </h4>
<p><a href="https://drive.google.com/file/d/1cSw_DoYaftVTcsIxOxUjfWsFZbA9muss/view?usp=share_link">https://drive.google.com/file/d/1cSw_DoYaftVTcsIxOxUjfWsFZbA9muss/view?usp=share_link</a><br>
<a href="https://drive.google.com/file/d/1A0dS4xWcSx6TZK-NsvqWNa3F2iCknK7V/view?usp=share_link">https://drive.google.com/file/d/1A0dS4xWcSx6TZK-NsvqWNa3F2iCknK7V/view?usp=share_link</a></p>
<h2 id="ejercicio-practico-2-modulo-gps-optativo">Ejercicio practico 2: Modulo GPS (optativo) </h2>
<p>He tenido que realizar las siguientes modificaciones al código para que funcionará:</p>
<ul>
<li>Eliminar las siguientes librerias:<pre data-role="codeBlock" data-info="" class="language-text"><code>#include &lt;SoftwareSerial.h&gt;
#include &lt;TinyGPS.h&gt;
</code></pre></li>
<li>Incluir la libreria:<pre data-role="codeBlock" data-info="" class="language-text"><code>#include &lt;TinyGPS++.h&gt;
</code></pre></li>
<li>Importante recordar que el puerto RX y el TX deben conectarse cruzados, sino no funcionará.</li>
</ul>
<h4 id="código-comentado-1">Código comentado </h4>
<pre data-role="codeBlock" data-info="" class="language-text"><code>// Incluye la librería TinyGPS++ para procesar datos de GPS (NMEA)
#include &lt;TinyGPS++.h&gt; 

// Crea un objeto llamado 'gps' para manejar y decodificar los datos recibidos del módulo GPS
TinyGPSPlus gps; 

// Crea un objeto 'mySerial' usando el puerto UART1 del ESP32
HardwareSerial mySerial(1); 

// Define el pin 16 como entrada RX (donde el ESP32 recibirá datos del GPS)
#define RX_PIN 16 

// Define el pin 17 como salida TX (no suele usarse para GPS, pero se define por claridad)
#define TX_PIN 17 

void setup()
{
  // Inicia la comunicación con el PC a 115200 baudios para mostrar datos en el monitor serie
  Serial.begin(115200); 

  // Espera hasta que la conexión con el monitor serie esté lista
  while (!Serial); 

  // Inicia UART1 a 9600 baudios con configuración 8N1, usando los pines definidos
  mySerial.begin(9600, SERIAL_8N1, RX_PIN, TX_PIN); 

  // Imprime un mensaje inicial informando que se está esperando datos del GPS
  Serial.println("Esperando coordenadas del GPS..."); 
}

void loop()
{
  // Mientras haya datos disponibles desde el GPS en UART1
  while (mySerial.available() &gt; 0) 
  {
    // Pasa cada byte recibido al objeto gps para que lo procese (decodifica sentencias NMEA)
    gps.encode(mySerial.read()); 

    // Si la ubicación fue actualizada con nuevos datos
    if (gps.location.isUpdated()) 
    {
      // Obtiene la latitud actual en grados decimales
      float latitude = gps.location.lat(); 

      // Obtiene la longitud actual en grados decimales
      float longitude = gps.location.lng(); 

      Serial.print("Latitud: ");
      // Muestra la latitud con 6 cifras decimales
      Serial.print(latitude, 6); 
      Serial.print("  Longitud: ");
      // Muestra la longitud con 6 cifras decimales
      Serial.print(longitude, 6); 
      Serial.println();

      Serial.print("Satélites: ");
      // Muestra el número de satélites detectados por el GPS
      Serial.println(gps.satellites.value()); 
    }
  }
}
</code></pre><h4 id="funcionamiento-1">Funcionamiento </h4>
<ol>
<li>Se comunica con un módulo GPS a través del puerto UART1 del ESP32 (usando los pines 16 y 17).</li>
<li>Lee continuamente los datos GPS enviados en formato NMEA.</li>
<li>Decodifica esos datos usando la librería TinyGPS++.</li>
<li>Cuando hay una nueva ubicación disponible, muestra:<br>
•	Latitud y longitud en el monitor serie.<br>
•	Cantidad de satélites conectados, lo que indica la calidad de la señal GPS.</li>
</ol>
<h4 id="salida-monitor-serial-1">Salida Monitor Serial </h4>
<p>La salida debe ser algo parecido a esta (con tus propias coordenadas):</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>Esperando coordenadas del GPS...
Latitud: 41.564594  Longitud: 2.023319
Satélites: 11
Latitud: 41.564594  Longitud: 2.023319
Satélites: 11
...
</code></pre><p>Como podemos comprobar, en nuestro caso, marca las coordenadas muy correctas de terrassa:<br>
<strong>Coordenadas terrassa: 41.5667, 2.0167</strong></p>
<h4 id="video-demostración">Video demostración </h4>
<p><a href="https://drive.google.com/file/d/1yJWaiWN7-h2pAZzLmAoFQTiHtOZTwXUB/view?usp=share_link">https://drive.google.com/file/d/1yJWaiWN7-h2pAZzLmAoFQTiHtOZTwXUB/view?usp=share_link</a></p>

      </div>
      
      
    
    
    
    
    
    
  
    </body></html>